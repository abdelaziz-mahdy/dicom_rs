// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'dicom.freezed.dart';

            // These functions are ignored because they are not marked as `pub`: `extract_all_tags`, `extract_metadata`, `process_directory_recursive`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`


            /// Loads a DICOM file from the given path
Future<DicomFile>  loadDicomFile({required String path }) => RustLib.instance.api.crateApiDicomLoadDicomFile(path: path);

/// Extracts pixel data from a DICOM file
Future<DicomImage>  extractPixelData({required String path }) => RustLib.instance.api.crateApiDicomExtractPixelData(path: path);

/// Gets a specific tag value from a DICOM file
Future<DicomValueType>  getTagValue({required String path , required String tagName }) => RustLib.instance.api.crateApiDicomGetTagValue(path: path, tagName: tagName);

/// Check if a file is a valid DICOM file
Future<bool>  isDicomFile({required String path }) => RustLib.instance.api.crateApiDicomIsDicomFile(path: path);

/// Get a list of all DICOM tags in a file
Future<List<String>>  listAllTags({required String path }) => RustLib.instance.api.crateApiDicomListAllTags(path: path);

/// Get encoded image bytes (PNG format) from a DICOM file
Future<Uint8List>  getEncodedImage({required String path }) => RustLib.instance.api.crateApiDicomGetEncodedImage(path: path);

/// Load all DICOM files from a directory
Future<List<DicomDirectoryEntry>>  loadDicomDirectory({required String dirPath }) => RustLib.instance.api.crateApiDicomLoadDicomDirectory(dirPath: dirPath);

/// Load all DICOM files recursively from a directory
Future<List<DicomDirectoryEntry>>  loadDicomDirectoryRecursive({required String dirPath }) => RustLib.instance.api.crateApiDicomLoadDicomDirectoryRecursive(dirPath: dirPath);

            
                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< AccessError>>
                abstract class AccessError implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< ConvertValueError>>
                abstract class ConvertValueError implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FileDicomObject < InMemDicomObject >>>
                abstract class FileDicomObjectInMemDicomObject implements RustOpaqueInterface {
                     Future<void>  element({required Tag tag });


 Future<void>  elementByName({required String name });


 Future<IterInMemElement>  iter();


static Future<FileDicomObjectInMemDicomObject>  openFile({required Path path })=>RustLib.instance.api.crateApiDicomFileDicomObjectInMemDicomObjectOpenFile(path: path);



                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<InMemElement>>
                abstract class InMemElement implements RustOpaqueInterface {
                     Future<void>  header();


 Future<int>  toInt();


 Future<void>  toStr();


 Future<int>  toU16();


 Future<int>  toU32();


 Future<void>  value();



                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Iter < 'static, InMemElement >>>
                abstract class IterInMemElement implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Path>>
                abstract class Path implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< ReadError>>
                abstract class ReadError implements RustOpaqueInterface {
                    

                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Tag>>
                abstract class Tag implements RustOpaqueInterface {
                    

                    
                }
                

@freezed
class DicomDirectoryEntry with _$DicomDirectoryEntry  {
                
                const factory DicomDirectoryEntry({ required  String path, required  DicomMetadata metadata, required  bool isValid,}) = _DicomDirectoryEntry;
                
                
                
            }

@freezed
class DicomFile with _$DicomFile  {
                
                const factory DicomFile({ required  String path, required  DicomMetadata metadata, required  List<DicomTag> allTags,}) = _DicomFile;
                
                
                
            }

@freezed
class DicomHandler with _$DicomHandler  {
                const DicomHandler._();
                const factory DicomHandler({}) = _DicomHandler;
                static Future<DicomHandler>  default_()=>RustLib.instance.api.crateApiDicomDicomHandlerDefault();


/// Gets a list of all tags in a DICOM file
 Future<List<DicomTag>>  getAllTags({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerGetAllTags(that: this, path: path);


/// Gets image bytes encoded as PNG from a DICOM file
 Future<Uint8List>  getImageBytes({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerGetImageBytes(that: this, path: path);


/// Gets all metadata from a DICOM file
 Future<DicomMetadata>  getMetadata({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerGetMetadata(that: this, path: path);


/// Extracts raw pixel data from a DICOM file
 Future<DicomImage>  getPixelData({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerGetPixelData(that: this, path: path);


/// Gets the value of a specific tag
 Future<DicomValueType>  getTagValue({required String path , required String tagName })=>RustLib.instance.api.crateApiDicomDicomHandlerGetTagValue(that: this, path: path, tagName: tagName);


/// Checks if a file is a valid DICOM file
 Future<bool>  isValidDicom({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerIsValidDicom(that: this, path: path);


/// Gets a list of all tag names in a DICOM file
 Future<List<String>>  listTags({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerListTags(that: this, path: path);


/// Loads all DICOM files from a directory (non-recursive)
 Future<List<DicomDirectoryEntry>>  loadDirectory({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerLoadDirectory(that: this, path: path);


/// Loads all DICOM files from a directory recursively
 Future<List<DicomDirectoryEntry>>  loadDirectoryRecursive({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerLoadDirectoryRecursive(that: this, path: path);


/// Loads a DICOM file and returns detailed information
 Future<DicomFile>  loadFile({required String path })=>RustLib.instance.api.crateApiDicomDicomHandlerLoadFile(that: this, path: path);


  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
/// Creates a new DicomHandler instance
static Future<DicomHandler>  newInstance()=>RustLib.instance.api.crateApiDicomDicomHandlerNew();


                
                
            }

@freezed
class DicomImage with _$DicomImage  {
                
                const factory DicomImage({ required  int width, required  int height, required  int bitsAllocated, required  int bitsStored, required  int highBit, required  int pixelRepresentation, required  String photometricInterpretation, required  int samplesPerPixel,  int? planarConfiguration, required  Uint8List pixelData,}) = _DicomImage;
                
                
                
            }

@freezed
class DicomMetadata with _$DicomMetadata  {
                
                const factory DicomMetadata({  String? patientName,  String? patientId,  String? studyDate,  String? accessionNumber,  String? modality,  String? studyDescription,  String? seriesDescription,  int? instanceNumber,  int? seriesNumber,}) = _DicomMetadata;
                
                
                
            }

@freezed
class DicomTag with _$DicomTag  {
                
                const factory DicomTag({ required  String tag, required  String vr, required  String name, required  DicomValueType value,}) = _DicomTag;
                
                
                
            }

@freezed
                sealed class DicomValueType with _$DicomValueType  {
                    const DicomValueType._();

                     const factory DicomValueType.str(  String field0,) = DicomValueType_Str;
 const factory DicomValueType.int(  int field0,) = DicomValueType_Int;
 const factory DicomValueType.float(  double field0,) = DicomValueType_Float;
 const factory DicomValueType.intList(  Int32List field0,) = DicomValueType_IntList;
 const factory DicomValueType.floatList(  Float32List field0,) = DicomValueType_FloatList;
 const factory DicomValueType.strList(  List<String> field0,) = DicomValueType_StrList;
 const factory DicomValueType.unknown() = DicomValueType_Unknown;

                    

                    
                }
            