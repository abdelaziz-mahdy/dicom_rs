// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'dicom_rs_interface.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `compute_row_length`, `create_metadata_from_dicomdir_entry`, `extract_all_tags`, `extract_dicomdir_record_metadata`, `extract_metadata`, `get_value_from_elements`, `load_from_dicomdir`, `organize_dicom_entries`, `parse_dicomdir_records`, `process_dicomdir_entries`, `process_directory_recursive`, `sort_dicom_entries_by_position`, `sort_dicom_entries`, `sort_dicom_hierarchy`, `sort_instances_by_position`, `to_el`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Loads a DICOM file from the given path.
Future<DicomFile> loadDicomFile({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceLoadDicomFile(path: path);

/// Extracts pixel data from a DICOM file.
Future<DicomImage> extractPixelData({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceExtractPixelData(path: path);

/// Gets a specific tag value from a DICOM file.
Future<DicomValueType> getTagValue({
  required String path,
  required String tagName,
}) => RustLib.instance.api.crateApiDicomRsInterfaceGetTagValue(
  path: path,
  tagName: tagName,
);

/// Check if a file is a valid DICOM file.
Future<bool> isDicomFile({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceIsDicomFile(path: path);

/// Get a list of all DICOM tags in a file.
Future<List<String>> listAllTags({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceListAllTags(path: path);

/// Get encoded image bytes (PNG) from a DICOM file.
Future<Uint8List> getEncodedImage({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceGetEncodedImage(path: path);

/// Loads all DICOM files from a directory.
Future<List<DicomDirectoryEntry>> loadDicomDirectory({
  required String dirPath,
}) => RustLib.instance.api.crateApiDicomRsInterfaceLoadDicomDirectory(
  dirPath: dirPath,
);

/// Loads all DICOM files recursively from a directory.
Future<List<DicomDirectoryEntry>> loadDicomDirectoryRecursive({
  required String dirPath,
}) => RustLib.instance.api.crateApiDicomRsInterfaceLoadDicomDirectoryRecursive(
  dirPath: dirPath,
);

/// Loads all DICOM files from a directory and organizes them hierarchically.
Future<List<DicomPatient>> loadDicomDirectoryOrganized({
  required String dirPath,
  required bool recursive,
}) => RustLib.instance.api.crateApiDicomRsInterfaceLoadDicomDirectoryOrganized(
  dirPath: dirPath,
  recursive: recursive,
);

/// Extracts all metadata from a DICOM file as a complete map.
Future<DicomMetadataMap> extractAllMetadata({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceExtractAllMetadata(path: path);

/// Checks if a file is a DICOMDIR file.
Future<bool> isDicomdirFile({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceIsDicomdirFile(path: path);

/// Parses a DICOMDIR file.
Future<DicomDirEntry> parseDicomdirFile({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceParseDicomdirFile(path: path);

/// Unified function to load DICOM files from a directory.
Future<List<DicomDirectoryEntry>> loadDicomDirectoryUnified({
  required String dirPath,
  required bool recursive,
}) => RustLib.instance.api.crateApiDicomRsInterfaceLoadDicomDirectoryUnified(
  dirPath: dirPath,
  recursive: recursive,
);

/// Computes slice spacing based on consecutive slices.
Future<double?> computeSliceSpacing({
  required List<DicomDirectoryEntry> entries,
}) => RustLib.instance.api.crateApiDicomRsInterfaceComputeSliceSpacing(
  entries: entries,
);

/// Flips the image data vertically.
Future<Uint8List> flipVertically({
  required List<int> pixelData,
  required int height,
  required BigInt rowLength,
}) => RustLib.instance.api.crateApiDicomRsInterfaceFlipVertically(
  pixelData: pixelData,
  height: height,
  rowLength: rowLength,
);

/// Loads a multi-slice volume from a directory of DICOM files.
Future<DicomVolume> loadVolumeFromDirectory({
  required String dirPath,
  FutureOr<void> Function(int, int)? progressCallback,
}) => RustLib.instance.api.crateApiDicomRsInterfaceLoadVolumeFromDirectory(
  dirPath: dirPath,
  progressCallback: progressCallback,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<El>>
abstract class El implements RustOpaqueInterface {
  String get tag;

  String get value;

  String get vr;

  set tag(String tag);

  set value(String value);

  set vr(String vr);
}

/// Represents an entry in a DICOMDIR file.
class DicomDirEntry {
  final String path;
  final String typeName;
  final Map<String, DicomValueType> metadata;
  final List<DicomDirEntry> children;

  const DicomDirEntry({
    required this.path,
    required this.typeName,
    required this.metadata,
    required this.children,
  });

  @override
  int get hashCode =>
      path.hashCode ^ typeName.hashCode ^ metadata.hashCode ^ children.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomDirEntry &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          typeName == other.typeName &&
          metadata == other.metadata &&
          children == other.children;
}

/// Legacy structure for backward compatibility.
class DicomDirectoryEntry {
  final String path;
  final DicomMetadata metadata;
  final bool isValid;

  const DicomDirectoryEntry({
    required this.path,
    required this.metadata,
    required this.isValid,
  });

  @override
  int get hashCode => path.hashCode ^ metadata.hashCode ^ isValid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomDirectoryEntry &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          metadata == other.metadata &&
          isValid == other.isValid;
}

/// Complete representation of a DICOM file.
class DicomFile {
  final String path;
  final DicomMetadata metadata;
  final List<DicomTag> allTags;

  const DicomFile({
    required this.path,
    required this.metadata,
    required this.allTags,
  });

  @override
  int get hashCode => path.hashCode ^ metadata.hashCode ^ allTags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomFile &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          metadata == other.metadata &&
          allTags == other.allTags;
}

/// Main interface for interacting with DICOM files and directories.
class DicomHandler {
  const DicomHandler();

  static Future<DicomHandler> default_() =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerDefault();

  Future<DicomMetadataMap> getAllMetadata({required String path}) =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerGetAllMetadata(
        that: this,
        path: path,
      );

  Future<List<DicomTag>> getAllTags({required String path}) => RustLib
      .instance
      .api
      .crateApiDicomRsInterfaceDicomHandlerGetAllTags(that: this, path: path);

  Future<Uint8List> getImageBytes({required String path}) =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerGetImageBytes(
        that: this,
        path: path,
      );

  Future<DicomMetadata> getMetadata({required String path}) => RustLib
      .instance
      .api
      .crateApiDicomRsInterfaceDicomHandlerGetMetadata(that: this, path: path);

  Future<DicomImage> getPixelData({required String path}) => RustLib
      .instance
      .api
      .crateApiDicomRsInterfaceDicomHandlerGetPixelData(that: this, path: path);

  Future<DicomValueType> getTagValue({
    required String path,
    required String tagName,
  }) => RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerGetTagValue(
    that: this,
    path: path,
    tagName: tagName,
  );

  Future<bool> isDicomdir({required String path}) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerIsDicomdir(that: this, path: path);

  Future<bool> isValidDicom({required String path}) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerIsValidDicom(that: this, path: path);

  Future<List<String>> listTags({required String path}) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerListTags(that: this, path: path);

  Future<List<DicomDirectoryEntry>> loadDirectory({required String path}) =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerLoadDirectory(
        that: this,
        path: path,
      );

  Future<List<DicomPatient>> loadDirectoryOrganized({required String path}) =>
      RustLib.instance.api
          .crateApiDicomRsInterfaceDicomHandlerLoadDirectoryOrganized(
            that: this,
            path: path,
          );

  Future<List<DicomDirectoryEntry>> loadDirectoryRecursive({
    required String path,
  }) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerLoadDirectoryRecursive(
        that: this,
        path: path,
      );

  Future<List<DicomPatient>> loadDirectoryRecursiveOrganized({
    required String path,
  }) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerLoadDirectoryRecursiveOrganized(
        that: this,
        path: path,
      );

  Future<List<DicomDirectoryEntry>> loadDirectoryUnified({
    required String path,
    required bool recursive,
  }) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerLoadDirectoryUnified(
        that: this,
        path: path,
        recursive: recursive,
      );

  Future<DicomFile> loadFile({required String path}) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerLoadFile(that: this, path: path);

  Future<DicomVolume> loadVolume({
    required String path,
    FutureOr<void> Function(int, int)? progressCallback,
  }) => RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerLoadVolume(
    that: this,
    path: path,
    progressCallback: progressCallback,
  );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<DicomHandler> newInstance() =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerNew();

  Future<DicomDirEntry> parseDicomdir({required String path}) =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerParseDicomdir(
        that: this,
        path: path,
      );

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomHandler && runtimeType == other.runtimeType;
}

/// Represents a DICOM imageâ€™s pixel data and associated parameters.
class DicomImage {
  final int width;
  final int height;
  final int bitsAllocated;
  final int bitsStored;
  final int highBit;
  final int pixelRepresentation;
  final String photometricInterpretation;
  final int samplesPerPixel;
  final int? planarConfiguration;
  final Uint8List pixelData;

  const DicomImage({
    required this.width,
    required this.height,
    required this.bitsAllocated,
    required this.bitsStored,
    required this.highBit,
    required this.pixelRepresentation,
    required this.photometricInterpretation,
    required this.samplesPerPixel,
    this.planarConfiguration,
    required this.pixelData,
  });

  @override
  int get hashCode =>
      width.hashCode ^
      height.hashCode ^
      bitsAllocated.hashCode ^
      bitsStored.hashCode ^
      highBit.hashCode ^
      pixelRepresentation.hashCode ^
      photometricInterpretation.hashCode ^
      samplesPerPixel.hashCode ^
      planarConfiguration.hashCode ^
      pixelData.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomImage &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          bitsAllocated == other.bitsAllocated &&
          bitsStored == other.bitsStored &&
          highBit == other.highBit &&
          pixelRepresentation == other.pixelRepresentation &&
          photometricInterpretation == other.photometricInterpretation &&
          samplesPerPixel == other.samplesPerPixel &&
          planarConfiguration == other.planarConfiguration &&
          pixelData == other.pixelData;
}

/// Represents a single DICOM instance (file) with spatial information.
class DicomInstance {
  final String path;
  final String? sopInstanceUid;
  final int? instanceNumber;
  final Float64List? imagePosition;
  final double? sliceLocation;
  final bool isValid;

  const DicomInstance({
    required this.path,
    this.sopInstanceUid,
    this.instanceNumber,
    this.imagePosition,
    this.sliceLocation,
    required this.isValid,
  });

  @override
  int get hashCode =>
      path.hashCode ^
      sopInstanceUid.hashCode ^
      instanceNumber.hashCode ^
      imagePosition.hashCode ^
      sliceLocation.hashCode ^
      isValid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomInstance &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          sopInstanceUid == other.sopInstanceUid &&
          instanceNumber == other.instanceNumber &&
          imagePosition == other.imagePosition &&
          sliceLocation == other.sliceLocation &&
          isValid == other.isValid;
}

/// Core metadata extracted from a DICOM file.
class DicomMetadata {
  final String? patientName;
  final String? patientId;
  final String? studyDate;
  final String? accessionNumber;
  final String? modality;
  final String? studyDescription;
  final String? seriesDescription;
  final int? instanceNumber;
  final int? seriesNumber;
  final String? studyInstanceUid;
  final String? seriesInstanceUid;
  final String? sopInstanceUid;
  final Float64List? imagePosition;
  final Float64List? imageOrientation;
  final double? sliceLocation;
  final double? sliceThickness;
  final double? spacingBetweenSlices;
  final Float64List? pixelSpacing;

  const DicomMetadata({
    this.patientName,
    this.patientId,
    this.studyDate,
    this.accessionNumber,
    this.modality,
    this.studyDescription,
    this.seriesDescription,
    this.instanceNumber,
    this.seriesNumber,
    this.studyInstanceUid,
    this.seriesInstanceUid,
    this.sopInstanceUid,
    this.imagePosition,
    this.imageOrientation,
    this.sliceLocation,
    this.sliceThickness,
    this.spacingBetweenSlices,
    this.pixelSpacing,
  });

  @override
  int get hashCode =>
      patientName.hashCode ^
      patientId.hashCode ^
      studyDate.hashCode ^
      accessionNumber.hashCode ^
      modality.hashCode ^
      studyDescription.hashCode ^
      seriesDescription.hashCode ^
      instanceNumber.hashCode ^
      seriesNumber.hashCode ^
      studyInstanceUid.hashCode ^
      seriesInstanceUid.hashCode ^
      sopInstanceUid.hashCode ^
      imagePosition.hashCode ^
      imageOrientation.hashCode ^
      sliceLocation.hashCode ^
      sliceThickness.hashCode ^
      spacingBetweenSlices.hashCode ^
      pixelSpacing.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomMetadata &&
          runtimeType == other.runtimeType &&
          patientName == other.patientName &&
          patientId == other.patientId &&
          studyDate == other.studyDate &&
          accessionNumber == other.accessionNumber &&
          modality == other.modality &&
          studyDescription == other.studyDescription &&
          seriesDescription == other.seriesDescription &&
          instanceNumber == other.instanceNumber &&
          seriesNumber == other.seriesNumber &&
          studyInstanceUid == other.studyInstanceUid &&
          seriesInstanceUid == other.seriesInstanceUid &&
          sopInstanceUid == other.sopInstanceUid &&
          imagePosition == other.imagePosition &&
          imageOrientation == other.imageOrientation &&
          sliceLocation == other.sliceLocation &&
          sliceThickness == other.sliceThickness &&
          spacingBetweenSlices == other.spacingBetweenSlices &&
          pixelSpacing == other.pixelSpacing;
}

/// Complete mapping of all DICOM metadata in a file.
class DicomMetadataMap {
  final Map<String, DicomTag> tags;
  final Map<String, Map<String, DicomTag>> groupElements;

  const DicomMetadataMap({required this.tags, required this.groupElements});

  @override
  int get hashCode => tags.hashCode ^ groupElements.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomMetadataMap &&
          runtimeType == other.runtimeType &&
          tags == other.tags &&
          groupElements == other.groupElements;
}

/// Represents a patient with associated DICOM studies.
class DicomPatient {
  final String? patientId;
  final String? patientName;
  final List<DicomStudy> studies;

  const DicomPatient({this.patientId, this.patientName, required this.studies});

  @override
  int get hashCode =>
      patientId.hashCode ^ patientName.hashCode ^ studies.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomPatient &&
          runtimeType == other.runtimeType &&
          patientId == other.patientId &&
          patientName == other.patientName &&
          studies == other.studies;
}

/// Represents a DICOM series containing multiple image instances.
class DicomSeries {
  final String? seriesInstanceUid;
  final int? seriesNumber;
  final String? seriesDescription;
  final String? modality;
  final List<DicomInstance> instances;

  const DicomSeries({
    this.seriesInstanceUid,
    this.seriesNumber,
    this.seriesDescription,
    this.modality,
    required this.instances,
  });

  @override
  int get hashCode =>
      seriesInstanceUid.hashCode ^
      seriesNumber.hashCode ^
      seriesDescription.hashCode ^
      modality.hashCode ^
      instances.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomSeries &&
          runtimeType == other.runtimeType &&
          seriesInstanceUid == other.seriesInstanceUid &&
          seriesNumber == other.seriesNumber &&
          seriesDescription == other.seriesDescription &&
          modality == other.modality &&
          instances == other.instances;
}

/// Represents a single slice from a DICOM volume.
class DicomSlice {
  final String path;
  final Uint8List data;

  const DicomSlice({required this.path, required this.data});

  @override
  int get hashCode => path.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomSlice &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          data == other.data;
}

/// Represents a DICOM study containing multiple series.
class DicomStudy {
  final String? studyInstanceUid;
  final String? studyDate;
  final String? studyDescription;
  final String? accessionNumber;
  final List<DicomSeries> series;

  const DicomStudy({
    this.studyInstanceUid,
    this.studyDate,
    this.studyDescription,
    this.accessionNumber,
    required this.series,
  });

  @override
  int get hashCode =>
      studyInstanceUid.hashCode ^
      studyDate.hashCode ^
      studyDescription.hashCode ^
      accessionNumber.hashCode ^
      series.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomStudy &&
          runtimeType == other.runtimeType &&
          studyInstanceUid == other.studyInstanceUid &&
          studyDate == other.studyDate &&
          studyDescription == other.studyDescription &&
          accessionNumber == other.accessionNumber &&
          series == other.series;
}

/// Represents a single DICOM tag with its value and metadata.
class DicomTag {
  final String tag;
  final String vr;
  final String name;
  final DicomValueType value;

  const DicomTag({
    required this.tag,
    required this.vr,
    required this.name,
    required this.value,
  });

  @override
  int get hashCode =>
      tag.hashCode ^ vr.hashCode ^ name.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomTag &&
          runtimeType == other.runtimeType &&
          tag == other.tag &&
          vr == other.vr &&
          name == other.name &&
          value == other.value;
}

@freezed
sealed class DicomValueType with _$DicomValueType {
  const DicomValueType._();

  const factory DicomValueType.str(String field0) = DicomValueType_Str;
  const factory DicomValueType.int(int field0) = DicomValueType_Int;
  const factory DicomValueType.float(double field0) = DicomValueType_Float;
  const factory DicomValueType.intList(Int32List field0) =
      DicomValueType_IntList;
  const factory DicomValueType.floatList(Float32List field0) =
      DicomValueType_FloatList;
  const factory DicomValueType.strList(List<String> field0) =
      DicomValueType_StrList;
  const factory DicomValueType.unknown() = DicomValueType_Unknown;
}

/// Represents a 3D volume constructed from 2D DICOM slices.
class DicomVolume {
  final int width;
  final int height;
  final int depth;
  final (double, double, double) spacing;
  final String dataType;
  final int numComponents;
  final List<DicomSlice> slices;

  const DicomVolume({
    required this.width,
    required this.height,
    required this.depth,
    required this.spacing,
    required this.dataType,
    required this.numComponents,
    required this.slices,
  });

  @override
  int get hashCode =>
      width.hashCode ^
      height.hashCode ^
      depth.hashCode ^
      spacing.hashCode ^
      dataType.hashCode ^
      numComponents.hashCode ^
      slices.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomVolume &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          depth == other.depth &&
          spacing == other.spacing &&
          dataType == other.dataType &&
          numComponents == other.numComponents &&
          slices == other.slices;
}
