// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `extract_elements`, `extract_metadata`, `get_element_value`, `to_element`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Check if a file is a valid DICOM file
Future<bool> isDicomFile({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceIsDicomFile(path: path);

/// Load a complete DICOM file
Future<DicomFile> loadDicomFile({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceLoadDicomFile(path: path);

/// Extract pixel data from a DICOM file
Future<DicomImage> extractPixelData({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceExtractPixelData(path: path);

/// Get encoded image bytes (PNG format) for display
Future<Uint8List> getEncodedImage({required String path}) =>
    RustLib.instance.api.crateApiDicomRsInterfaceGetEncodedImage(path: path);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DicomElement>>
abstract class DicomElement implements RustOpaqueInterface {
  String get tag;

  String get value;

  String get vr;

  set tag(String tag);

  set value(String value);

  set vr(String vr);
}

/// Complete DICOM file representation
class DicomFile {
  final String path;
  final DicomMetadata metadata;
  final DicomImage? image;
  final bool isValid;

  const DicomFile({
    required this.path,
    required this.metadata,
    this.image,
    required this.isValid,
  });

  @override
  int get hashCode =>
      path.hashCode ^ metadata.hashCode ^ image.hashCode ^ isValid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomFile &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          metadata == other.metadata &&
          image == other.image &&
          isValid == other.isValid;
}

/// Main handler for DICOM operations
class DicomHandler {
  const DicomHandler();

  static Future<DicomHandler> default_() =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerDefault();

  /// Extract raw pixel data and image parameters
  Future<DicomImage> extractPixelData({required String path}) =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerExtractPixelData(
        that: this,
        path: path,
      );

  /// Get encoded image bytes (PNG format) for display
  Future<Uint8List> getImageBytes({required String path}) =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerGetImageBytes(
        that: this,
        path: path,
      );

  /// Extract only metadata from a DICOM file (faster than full load)
  Future<DicomMetadata> getMetadata({required String path}) => RustLib
      .instance
      .api
      .crateApiDicomRsInterfaceDicomHandlerGetMetadata(that: this, path: path);

  /// Check if a file is a valid DICOM file
  Future<bool> isDicomFile({required String path}) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerIsDicomFile(that: this, path: path);

  /// Load a complete DICOM file with metadata and image data
  Future<DicomFile> loadFile({required String path}) => RustLib.instance.api
      .crateApiDicomRsInterfaceDicomHandlerLoadFile(that: this, path: path);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<DicomHandler> newInstance() =>
      RustLib.instance.api.crateApiDicomRsInterfaceDicomHandlerNew();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomHandler && runtimeType == other.runtimeType;
}

/// DICOM image pixel data and basic parameters
class DicomImage {
  final int width;
  final int height;
  final int bitsAllocated;
  final int bitsStored;
  final int pixelRepresentation;
  final String photometricInterpretation;
  final int samplesPerPixel;
  final Uint8List pixelData;

  const DicomImage({
    required this.width,
    required this.height,
    required this.bitsAllocated,
    required this.bitsStored,
    required this.pixelRepresentation,
    required this.photometricInterpretation,
    required this.samplesPerPixel,
    required this.pixelData,
  });

  @override
  int get hashCode =>
      width.hashCode ^
      height.hashCode ^
      bitsAllocated.hashCode ^
      bitsStored.hashCode ^
      pixelRepresentation.hashCode ^
      photometricInterpretation.hashCode ^
      samplesPerPixel.hashCode ^
      pixelData.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomImage &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          bitsAllocated == other.bitsAllocated &&
          bitsStored == other.bitsStored &&
          pixelRepresentation == other.pixelRepresentation &&
          photometricInterpretation == other.photometricInterpretation &&
          samplesPerPixel == other.samplesPerPixel &&
          pixelData == other.pixelData;
}

/// Core metadata extracted from a DICOM file
class DicomMetadata {
  final String? patientName;
  final String? patientId;
  final String? studyDate;
  final String? modality;
  final String? studyDescription;
  final String? seriesDescription;
  final int? instanceNumber;
  final int? seriesNumber;
  final String? studyInstanceUid;
  final String? seriesInstanceUid;
  final String? sopInstanceUid;
  final Float64List? imagePosition;
  final Float64List? pixelSpacing;
  final double? sliceLocation;
  final double? sliceThickness;

  const DicomMetadata({
    this.patientName,
    this.patientId,
    this.studyDate,
    this.modality,
    this.studyDescription,
    this.seriesDescription,
    this.instanceNumber,
    this.seriesNumber,
    this.studyInstanceUid,
    this.seriesInstanceUid,
    this.sopInstanceUid,
    this.imagePosition,
    this.pixelSpacing,
    this.sliceLocation,
    this.sliceThickness,
  });

  @override
  int get hashCode =>
      patientName.hashCode ^
      patientId.hashCode ^
      studyDate.hashCode ^
      modality.hashCode ^
      studyDescription.hashCode ^
      seriesDescription.hashCode ^
      instanceNumber.hashCode ^
      seriesNumber.hashCode ^
      studyInstanceUid.hashCode ^
      seriesInstanceUid.hashCode ^
      sopInstanceUid.hashCode ^
      imagePosition.hashCode ^
      pixelSpacing.hashCode ^
      sliceLocation.hashCode ^
      sliceThickness.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DicomMetadata &&
          runtimeType == other.runtimeType &&
          patientName == other.patientName &&
          patientId == other.patientId &&
          studyDate == other.studyDate &&
          modality == other.modality &&
          studyDescription == other.studyDescription &&
          seriesDescription == other.seriesDescription &&
          instanceNumber == other.instanceNumber &&
          seriesNumber == other.seriesNumber &&
          studyInstanceUid == other.studyInstanceUid &&
          seriesInstanceUid == other.seriesInstanceUid &&
          sopInstanceUid == other.sopInstanceUid &&
          imagePosition == other.imagePosition &&
          pixelSpacing == other.pixelSpacing &&
          sliceLocation == other.sliceLocation &&
          sliceThickness == other.sliceThickness;
}
